process PROD  = {

  	source = PoolSource {
    		untracked vstring fileNames = { "file:evtgen_detsim_digi.root" }
    		untracked int32 maxEvents = -1
  	}


        module out = PoolOutputModule {
            untracked string fileName = 'evtgen_jets.root'
            untracked vstring outputCommands = 
          {
            "keep *",
            "drop *_muonCSCDigis_*_*",
            "drop *_muonDTDigis_*_*",
            "drop *_siStripDigis_*_*",
            "drop *_siPixelDigis_*_*",
            "drop *_hcalDigis_*_*",
            "drop *_ecalUnsuppressedDigis_*_*",
            "drop *_g4SimHits_*_*"
          }
        } 
	
   es_module = EcalPreshowerGeometryEP {}
   es_module = EcalBarrelGeometryEP {}
   es_module = EcalEndcapGeometryEP {}
   es_module = HcalHardcodeGeometryEP {}
   es_module = CaloTowerHardcodeGeometryEP {}
   es_module = CaloGeometryBuilder {}
   es_module = CaloTowerTopologyBuilder {}
   es_module = HcalTopologyIdealEP {}

#HCAL calibrations
   es_module = HcalDbProducer {}
   es_source es_hardcode = HcalHardcodeCalibrations 
   {
      untracked vstring toGet = 
      {
         "Pedestals", "PedestalWidths", 
	 "Gains", "GainWidths", 
	 "QIEShape", "QIEData", 
	 "ChannelQuality", "ElectronicsMap"
      }
   }

      #Geometry
   #
   es_source = XMLIdealGeometryESSource 
   { 
      FileInPath GeometryConfiguration = "Geometry/CMSCommonData/data/simConfiguration.xml"
      #the proper root node is set in the xml file
      string rootNodeName = ""
   }
   es_module = TrackerGeometricDetESModule {}

#Magnetic Field
   #
   include "MagneticField/Engine/data/volumeBasedMagneticField.cfi"

  # include "SimGeneral/HepPDTESSource/data/pdt.cfi"
   es_source = HepPDTESSource {
     string pdtFileName = "/afs/cern.ch/cms/external/lcg/external/HepPDT/2.02.02/slc3_ia32_gcc323/data/PDG_mass_width_2004.mc"
   } 

# this one makes candidates from generator partigles
   module genCandidates = HepMCCandidateProducer {
# pick right source - different for different generators
   	string src = "PythiaSource"
   	# string src = "FlatRandomPtGunSource"
        untracked bool verbose = false
        bool stableOnly = true
    	# vstring excludeList = { "nu(e)0", "nu(mu)0", "nu(tau)0", "mu-", "K(L)0", "n0" }
    	vstring excludeList = { }
  }

#
# Calorimetry
#
###################################################################
 # Get hardcoded conditions the same used for standard digitization
  es_source = EcalTrivialConditionRetriever {
       #untracked double adcToGeVEBConstant = 0.0286
      untracked double adcToGeVEBConstant = 0.0636
  }
 ###################################################################


 #######################################################################################	
 # EB+EE uncalibrated RecHit producer 
 # Weight method (CMS standard requires tuned weights) 	
 include "RecoLocalCalo/EcalRecProducers/data/EcalWeightUncalibratedRecHitProducer.cfi"	
 # Analytic fit (much slower does not require weights) 	
 # include "RecoLocalCalo/EcalRecProducers/data/EcalAnalFitUncalibratedRecHitProducer.cfi"	
 #######################################################################################

 #######################################################################################
 # EB+EE RecHit producer (from uncalibrated RecHit)
 include "RecoLocalCalo/EcalRecProducers/data/EcalRecHitProducer.cfi"	
 #######################################################################################

 #######################################################################################
 # ES RecHit producer (from Digis)
 include "RecoLocalCalo/EcalRecProducers/data/ESRecHitProducer.cfi"	
 #######################################################################################


   # HBHE rechit producer
   module recohbhe = HcalSimpleReconstructor {
          int32 firstSample = 4
          int32 samplesToAdd = 4
          string Subdetector = 'HBHE'
          string digiLabel = 'hcalDigis'
          bool correctForTimeslew = true
   }

   # HO rechit producer
   module recoho = HcalSimpleReconstructor {
          int32 firstSample = 4
          int32 samplesToAdd = 4
          string Subdetector = 'HO'
          string digiLabel = 'hcalDigis'
          bool correctForTimeslew = true
   }

   # HF rechit producer
   module recohf = HcalSimpleReconstructor {
          int32 firstSample = 2
          int32 samplesToAdd = 2
          string Subdetector = 'HF'
          string digiLabel = 'hcalDigis'
          bool correctForTimeslew = true
   }


# this one makes CaloTowers without EE energy
include "RecoJets/JetProducers/data/CaloTowerSchemeBnoEE.cfi"


# this one makes candidates from CaloTowers
   module caloTowers = CaloTowerCandidateCreator {
          string src = "towermaker"
	    double et = 0
	    double e = 0
	    double pt = 0
   }

#include "RecoJets/JetProducers/data/CaloJetKt.cfi"
include "RecoJets/JetProducers/data/CaloJetMcone5.cfi"
include "RecoJets/JetProducers/data/CaloJetMcone7.cfi"
include "RecoJets/JetProducers/data/CaloJetIcone5.cfi"
#include "RecoJets/JetProducers/data/GenJetKt.cfi"
include "RecoJets/JetProducers/data/GenJetMcone5.cfi"
include "RecoJets/JetProducers/data/GenJetMcone7.cfi"
include "RecoJets/JetProducers/data/GenJetIcone5.cfi"

   # Now order modules execution
   #
   sequence doHReco  = { recohbhe, recoho, recohf }
   sequence doEReco  = { ecaluncalibrechit, ecalrechit }
   #sequence doRecoJets = {towermaker, caloTowers, CaloJetKt, CaloJetMcone5, CaloJetMcone7, CaloJetIcone5}
   #sequence doGenJets = {genCandidates, GenJetKt, GenJetMcone5, GenJetMcone7, GenJetIcone5}
   sequence doRecoJets = {towermaker, caloTowers, midPointCone5CaloJets, midPointCone7CaloJets, iterativeCone5CaloJets}
   sequence doGenJets = {genCandidates, midPointCone5GenJets, midPointCone7GenJets, iterativeCone5GenJets }
   path p1 = {doEReco, doHReco, doGenJets, doRecoJets}
   endpath outpath = { out }
		
}		
