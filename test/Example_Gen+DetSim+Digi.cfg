#
# configuration to run MC generator followed by GEANT simulation and digitization
# based on  SimG4Core/Application/test/EvtGen+DetSim+Digi.cfg
# tested with CMSSW_0_6_0_pre3
# F. Ratnikov
#

process PROD  = {


   service = MessageLogger
   {
      untracked vstring destinations = {"cout"}
      
      vstring categories = { "FwkJob" }

      PSet cout = { PSet default = { int32 limit = 0 }    # kill all messages in the log
                    PSet FwkJob  = { int32 limit = -1 } } # except *all* of FwkJob's	  
      
      untracked vstring fwkJobReports = {"FrameworkJobReport.xml"}
   }

   service = Timing {}


   service = RandomNumberGeneratorService
   {
      untracked uint32 sourceSeed = 135799753
      PSet moduleSeeds =
      {
         untracked uint32 VtxSmeared = 123456789
      }
   }


   # NOTE : if one wants to run with the SiStripDigitizer,
   #        then mag.field in the OscarProducer should be
   #        turned ON; otherwise it gets (re)created by the
   #        SiStripDigitizer, which seems to corrupt at all
   #        the edm::Event record


   # Step 1 : Event Generation

#   include "pythia_Z700_dijets.cfi"
   include "pt_gun.cfi"


   # Vtx Smearing
   include "IOMC/EventVertexGenerators/data/VtxSmearedGauss.cfi"

   #Geometry
   #
   include "Geometry/CMSCommonData/data/cmsSimIdealGeometryXML.cfi"
   es_module = TrackerGeometricDetESModule {}

   #Magnetic Field
   #
   include "MagneticField/Engine/data/volumeBasedMagneticField.cfi"

   # Step 2 : CMS Detector Simulation

   # CMS Det.Simulation module (OscarProducer)
   #
   module SimG4Object = OscarProducer
   {
      bool NonBeamEvent = false
      untracked int32 RunNumber = 1001
      untracked int32 G4EventManagerVerbosity = 0
      untracked int32 G4StackManagerVerbosity = 0
      untracked int32 G4TrackingManagerVerbosity = 0
      bool UseMagneticField = true
      # bool UseMagneticField = false
      bool OverrideUserStackingAction = true
      bool StoreRndmSeeds = false
      bool RestoreRndmSeeds = false
      string PhysicsTablesDirectory = "PhysicsTables"
      bool StorePhysicsTables = false
      bool RestorePhysicsTables = false
      #VPSet Watchers = {
      # { string type = "SimTracer"
      #   bool verbose = true }
      #}
      PSet MagneticField =
      {
         double delta = 1.
      }
      PSet Physics =
      {
         # NOTE : if you want EM Physics only,
         #        please select "SimG4Core/Physics/DummyPhysics" for type
         #        and turn ON DummyEMPhysics
         #
         string type = "SimG4Core/Physics/QGSP"
         bool DummyEMPhysics = false
         bool CutsPerRegion = true
         double DefaultCutValue = 1000.  # cuts in cm, i.e. 10m
         untracked int32 Verbosity = 0   # 1 will print cuts as they get set fdrom DD
                                         # 2 will do as 1 + will dump Geant4 table of cuts
      }
      PSet Generator =
      {
         bool ApplyPtCuts = true
         bool ApplyEtaCuts = true
         bool ApplyPhiCuts = false
         double MinPhiCut = 0.   # in degrees,
         double MaxPhiCut = 360. # internally converted to radians, (-pi,pi) range accounted for
         double MinEtaCut = -5.5
         double MaxEtaCut = 5.5
         double MinPtCut = 40.
         double MaxPtCut = 999999.
         untracked int32 Verbosity = 0
      }

      PSet RunAction = { string StopFile = "StopRun" }
      PSet EventAction =
      {
         bool CollapsePrimaryVertices = false
         string StopFile = "StopRun"
         untracked bool debug = false
      }

      PSet TrackingAction =
      {
         untracked bool DetailedTiming = false
      }
      PSet UtilityActions =
      {
               string type = "SimG4Core/UtilityAction/TrackingVerboseAction"
               untracked bool  DEBUG = false
               untracked bool  CheckForHighEtPhotons = false
               untracked int32 EventMin = 0
               untracked int32 EventMax = 0
               untracked int32 EventStep = 1
               untracked int32 TrackMin = 0
               untracked int32 TrackMax = 0
               untracked int32 TrackStep = 1
               untracked int32 VerboseLevel = 0 
      }
      PSet SteppingAction =
      {
         bool   KillBeamPipe = true
         double CriticalEnergyForVacuum = 2.0
#         double CriticalDensity = 1.e-25 is crazy and makes trouble (F.R.)
         double CriticalDensity = 1.e-15
         untracked int32  Verbosity = 0
      }
      PSet TrackerSD =
      {
         bool    ZeroEnergyLoss = false
         bool    NeverAccumulate = false
         bool    PrintHits = false
         double  ElectronicSigmaInNanoSeconds = 12.06
         double  EnergyThresholdForPersistencyInGeV = 0.5
         double  EnergyThresholdForHistoryInGeV = 0.05
      }
      PSet MuonSD =
      {
         double  EnergyThresholdForPersistency = 1.0
         bool    AllMuonsPersistent = false
         bool    PrintHits = false
      }

      PSet CaloSD = {
         double EminTrack = 1.0
         untracked int32  CheckHits = 25
         untracked bool   UseMap = true
         #int32  Verbosity = 1
         untracked int32 Verbosity = 0
         untracked bool   DetailedTiming = false
      }
      PSet ECalSD = {
         bool   UseBirkLaw = false
         double BirkC1 = 0.013
         double BirkC2 = 9.6e-6
         #int32  Verbosity = 11
         int32 Verbosity = 0
      }
      PSet HCalSD = {
         bool   UseBirkLaw = false
         double BirkC1 = 0.013
         double BirkC2 = 9.6e-6
         #int32  Verbosity = 111
         int32 Verbosity = 0
         bool   UseShowerLibrary = true
         bool   TestNumberingScheme = false
      }
      PSet CaloTrkProcessing = {
         #int32  Verbosity = 1
         int32 Verbosity = 0
         bool   TestBeam  = false
         double EminTrack = 0.01
      }
      PSet HFShower =    {
         #int32  Verbosity = 11
         int32 Verbosity = 0
         double ProbMax   = 0.7268
         double CFibre    = 0.50
      }
      PSet HFShowerLibrary = {
         FileInPath FileName = "SimG4CMS/Calo/data/hfshowerlibrary_lhep.root"
         string TreeEMID  = "h3"
         string TreeHadID = "h8"
      }
      PSet HFCherenkov = {
         #int32  Verbosity       = 1
         int32 Verbosity = 0
         double RefIndex        = 1.459
         double Lambda1         = 280.0
         double Lambda2         = 700.0
         double Aperture        = 0.33
         double ApertureTrapped = 0.22
         double Gain            = 0.33
         bool   CheckSurvive    = false
      }
   }  # end of OscarProducer's PSet's/block


   # Step 3 : Digitization of the simulated hits
   #

   # Step 3a : Digitization of the Tracker
   #

   # required for Pixel and SiStrip Digitizers
   #
   es_module = TrackerDigiGeometryESModule {}

   # Pixel's digitization
   #
   include "SimTracker/SiPixelDigitizer/data/PixelDigi.cfi"

   # SiStrip's digitization
   #
   include "SimTracker/SiStripDigitizer/data/SiStripDigi.cfi"

   # Step 3b : Digitization of Ecal and Hcal

   # required for Ecal and Hcal Digitizers
   # NOTE : Both Ecal and Hcal geometries need to be present,
   #        even if only one digitizers is to run
   #
   es_module = EcalPreshowerGeometryEP {}
   es_module = EcalBarrelGeometryEP {}
   es_module = EcalEndcapGeometryEP {}
   es_module = HcalHardcodeGeometryEP {}
   es_module = CaloTowerHardcodeGeometryEP {}
   es_module = CaloGeometryBuilder {}

   es_module = HcalDbProducer {}
   es_source es_hardcode = HcalHardcodeCalibrations
   {
      untracked vstring toGet =
      {
         "Pedestals", "PedestalWidths",
         "Gains", "GainWidths",
         "QIEShape", "QIEData",
         "ChannelQuality", "ElectronicsMap"
      }
   }

   include "SimCalorimetry/EcalSimProducers/data/ecaldigi.cfi"
   
   include "SimCalorimetry/HcalSimProducers/data/hcaldigi.cfi"


   # Step 3c : Muon Digitization


   # this holds CSC geom service, as need for CSC digi's
   # and the digitizer itself
   #
   include "Geometry/CSCGeometry/data/cscGeometry.cfi"
   include "SimMuon/CSCDigitizer/data/muoncscdigi.cfi"

   # Muon DT digi's

   # this holds geom.service as needed by DT digi's
   # and the digitizer itself
   #
   include "Geometry/DTGeometry/data/dtGeometry.cfi"
   include "SimMuon/DTDigitizer/data/muondtdigi.cfi"

   # Mixing Module is *required* to simulated Ecal/Hcal/Muon digitization !

   module mix = MixingModule
   {
#      secsource input = PoolRASource
#      {
         #
         # starting 050, you can skip secsource block at all if you don't
         # wnat to model mixing/pileup at all;
         # however, an at least "empty mixing" need to be present if you
         # want to perform Ecal/Hcal/CSC/DT digitization - those explicitely
         # require presence of CrossingFrame in the edm::Event
         #
         # alternatively, you can set averageNumber=0 if you don't want
         # to model the pileup
         #
         # to the secsource/PoolRASource, you can give just 1 file or more;
         # this files will make a "concatinated buffer", which will go circular
         # until the loop of primary events is done - thus, it'll never run out
         #
         # WARNING: you can only give miltiple files, if they're generated with
         #          identical sets of tracked parameters;
         #          for example, you canNOT give a file made with a single muon
         #          gun and a file made with a single pion gun, because PartID
         #          is a *tracked* parameter in the gun's PSet;
         #          however, you can merge together files made with other generators,
         #          for example, PythiaSource, because all parameters of it would be
         #          *untracked*
         #
#         untracked vstring fileNames =
#         {'file:/afs/cern.ch/cms/geant4rep/genntpl/muon_simhit_for_pileup.060pre1.root' }
#         untracked vstring fileNames =
#         {'file:simevent.root' }
#         string type = "poisson"
#         double averageNumber = 3  # setting this param. to 0 means "No pile-up",
                                   # that is, digitize current crossing only
#         int32 minBunch = -3
#         int32 maxBunch = 5
#         int32 seed = 1234567
#      }
      int32 bunchspace = 25
   }

   # Step 4 : Output module
   #
   module GEN-SIM-DIGI = PoolOutputModule
   {
      untracked string fileName = "evtgen_detsim_digi.root"
   }
   
   # Now order modules for execution
   #
   sequence trDigi = {  siPixelDigis & siStripDigis }
   sequence calDigi = { ecalUnsuppressedDigis & hcalDigis }
   sequence muonDigi = { muonCSCDigis &  muonDTDigis }
   sequence doDigi = { trDigi & calDigi & muonDigi  }
   path p1 = { VtxSmeared, SimG4Object, mix, doDigi }
   endpath outpath = { GEN-SIM-DIGI }

}
